{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"coloration/","level":1,"title":"Exercices Corrigés - Coloration","text":"<p>Voici les corrections pour la série d'exercices sur la coloration de graphes.</p>","path":["Exercices Corrigés - Coloration"],"tags":[]},{"location":"coloration/#exercice-1-relation-entre-chi-et-omega","level":2,"title":"Exercice 1 : Relation entre Chi et Omega","text":"<p>Question : Laquelle de ces affirmations est vraie ? *   Chi &lt;= Omega *   Omega &lt;= Chi</p> <p>Réponse : Omega &lt;= Chi est VRAIE.</p> <ul> <li>Omega (w) est la taille de la plus grande clique (un groupe de sommets tous reliés entre eux).</li> <li>Chi (x) est le nombre chromatique (nombre minimum de couleurs pour colorier le graphe).</li> </ul> <p>Explication : Dans une clique de taille k, chaque sommet est relié à tous les autres. Il est donc impossible de donner la même couleur à deux sommets de la clique. Il faut donc obligatoirement au moins k couleurs différentes juste pour colorier cette clique. Par conséquent, le nombre total de couleurs nécessaires pour le graphe entier (Chi) est forcément supérieur ou égal à la taille de la plus grande clique (Omega).</p>","path":["Exercices Corrigés - Coloration"],"tags":[]},{"location":"coloration/#exercice-2-algorithme-glouton-sur-knn-moins-un-couplage","level":2,"title":"Exercice 2 : Algorithme Glouton sur Kn,n moins un couplage","text":"<p>Graphe : G est un graphe biparti complet Kn,n (deux ensembles A et B de n sommets) auquel on a retiré un couplage parfait (on a enlevé les arêtes (a1, b1), (a2, b2)... (an, bn)). Cela signifie que a_i est relié à tous les b_j sauf b_i.</p> <p>1. Permutation pour 2 couleurs (Minimum) Puisque le graphe est biparti (les arêtes ne vont que de A vers B), il est 2-coloriable. *   Ordre : D'abord tous les sommets de A, puis tous les sommets de B.     *   a1, a2, ..., an, b1, b2, ..., bn *   Exécution :     *   Tous les a_i prennent la couleur 1 (ils ne sont pas reliés entre eux).     *   Tous les b_i prennent la couleur 2 (ils sont reliés aux a_i, donc pas couleur 1, mais pas reliés entre eux). *   Total : 2 couleurs.</p> <p>2. Permutation pour un nombre maximum de couleurs On veut piéger l'algorithme glouton. *   Ordre : a1, b1, a2, b2, ..., an, bn. *   Exécution :     *   a1 : Couleur 1.     *   b1 : N'est PAS relié à a1 (arête retirée). Prend la couleur 1.     *   a2 : Relié à b1 (couleur 1). Prend la couleur 2.     *   b2 : Relié à a1 (couleur 1). N'est PAS relié à a2. Prend la couleur 2.     *   a3 : Relié à b1 (1) et b2 (2). Prend la couleur 3.     *   b3 : Relié à a1 (1) et a2 (2). Prend la couleur 3.     *   ...     *   an, bn : Reliés à tous les b_j et a_j précédents (couleurs 1 à n-1). Prennent la couleur n. *   Total : n couleurs seront utilisées.</p>","path":["Exercices Corrigés - Coloration"],"tags":[]},{"location":"coloration/#exercice-3-sommet-darticulation","level":2,"title":"Exercice 3 : Sommet d'articulation","text":"<p>Question : Soit v un sommet d'articulation séparant le graphe en deux blocs G1 et G2. Montrez que Chi(G) = max(Chi(G1), Chi(G2)).</p> <p>Preuve : 1.  Borne inférieure : G contient G1 et G2 comme sous-graphes. Donc il faut au moins autant de couleurs que pour G1 et autant que pour G2. Donc Chi(G) &gt;= max(Chi(G1), Chi(G2)). 2.  Borne supérieure (Construction) :     *   Coloriez G1 avec k1 = Chi(G1) couleurs. Le sommet v reçoit une couleur c1.     *   Coloriez G2 avec k2 = Chi(G2) couleurs. Le sommet v reçoit une couleur c2.     *   Supposons k1 &gt;= k2. On a k1 couleurs disponibles.     *   Dans le coloriage de G2, on peut permuter les couleurs (échanger les noms des couleurs) pour faire en sorte que v reçoive la couleur c1 (la même que dans G1).     *   Maintenant, les deux coloriages sont compatibles au niveau du sommet v (le seul point commun).     *   On fusionne les deux coloriages. Le nombre total de couleurs utilisé est max(k1, k2).</p>","path":["Exercices Corrigés - Coloration"],"tags":[]},{"location":"coloration/#exercice-4-graphes-k-degeneres","level":2,"title":"Exercice 4 : Graphes k-dégénérés","text":"<p>Définition : Un graphe est k-dégénéré si on peut le réduire à vide en supprimant successivement des sommets de degré &lt;= k.</p> <p>1. Équivalence Un graphe est k-dégénéré SI ET SEULEMENT SI tout sous-graphe contient au moins un sommet de degré &lt;= k. *   Si on peut supprimer successivement, à chaque étape le sommet supprimé avait degré &lt;= k dans le graphe restant (qui est un sous-graphe). *   Inversement, si tout sous-graphe a un sommet de degré faible, on peut toujours en trouver un à supprimer pour continuer la réduction.</p> <p>2. Graphes 1-dégénérés Ce sont les graphes qui contiennent toujours un sommet de degré 0 ou 1. Si on supprime ces sommets récursivement, on finit par tout supprimer. Cela correspond aux Forêts (graphes sans cycles). *   Un cycle a tous ses sommets de degré 2. Donc un graphe avec un cycle n'est pas 1-dégénéré (le cycle restera bloqué).</p> <p>3. k-dégénéré =&gt; (k+1)-coloriable Utilisons l'algorithme glouton avec un ordre intelligent. *   Ordre : L'inverse de l'ordre de suppression. On commence par le dernier sommet supprimé, on remonte jusqu'au premier. *   Soit v un sommet dans cet ordre. Quand c'est son tour d'être colorié, il a un certain nombre de voisins déjà coloriés. *   Ces voisins sont ceux qui étaient après lui dans l'ordre de suppression (donc présents dans le graphe au moment où v a été supprimé). *   Par définition de la k-dégénérescence, v avait au plus k voisins dans ce graphe résiduel. *   Donc v a au plus k voisins déjà coloriés. *   Parmi k+1 couleurs disponibles, il en reste forcément au moins une libre pour v. *   Donc le graphe est (k+1)-coloriable.</p>","path":["Exercices Corrigés - Coloration"],"tags":[]},{"location":"coloration/#exercice-5-theoreme-de-vizing","level":2,"title":"Exercice 5 : Théorème de Vizing","text":"<p>Question : Montrez le théorème de Vizing : Chi' &lt;= Delta + 1.</p> <p>Définitions : *   Chi' (x') : Indice chromatique (nombre de couleurs pour colorier les ARÊTES). *   Delta : Degré maximum du graphe.</p> <p>Énoncé : Le nombre de couleurs nécessaires pour colorier les arêtes d'un graphe est soit égal au degré maximum (Delta), soit égal à Delta + 1. *   On a évidemment Chi' &gt;= Delta (car un sommet de degré Delta a Delta arêtes incidentes qui doivent toutes avoir des couleurs différentes). *   Vizing a prouvé que l'on n'a jamais besoin de plus de Delta + 1 couleurs.</p> <p>Note : La preuve complète est complexe et dépasse généralement le cadre d'un simple exercice, mais le résultat est fondamental à connaître. Pour les graphes bipartis, on a toujours Chi' = Delta. Pour les graphes généraux, c'est soit Delta (Classe 1), soit Delta + 1 (Classe 2).</p>","path":["Exercices Corrigés - Coloration"],"tags":[]},{"location":"exercices_corriges/","level":1,"title":"Exercices Corrigés - Arbres Couvrants","text":"<p>Voici les corrections détaillées pour les exercices demandés.</p>","path":["Exercices Corrigés - Arbres Couvrants"],"tags":[]},{"location":"exercices_corriges/#exercice-2-borne-superieure-sur-le-nombre-darbres-couvrants","level":2,"title":"Exercice 2 : Borne supérieure sur le nombre d'arbres couvrants","text":"<p>Question : Donnez une borne supérieure sur le nombre d'arbres couvrants qu'un graphe à n sommets peut avoir.</p> <p>Réponse : La borne supérieure est donnée par la formule de Cayley. Pour un graphe complet K_n (où toutes les paires de sommets sont reliées), le nombre d'arbres couvrants est exactement : n puissance (n-2)</p> <p>Puisque tout graphe à n sommets est un sous-graphe du graphe complet K_n, il ne peut pas avoir plus d'arbres couvrants que K_n. Donc, le nombre d'arbres couvrants est au maximum n^(n-2).</p>","path":["Exercices Corrigés - Arbres Couvrants"],"tags":[]},{"location":"exercices_corriges/#exercice-3-poids-negatifs-et-maximum","level":2,"title":"Exercice 3 : Poids négatifs et Maximum","text":"<p>1. Si les valuations des arêtes sont toutes négatives. Est-ce que le problème est plus difficile que le cas où les arêtes sont de poids positifs ?</p> <p>Réponse : Non. Les algorithmes de Kruskal et Prim fonctionnent par comparaison de poids (trouver le minimum, trier). *   Si on ajoute une constante C à toutes les arêtes pour les rendre positives, l'ordre des arêtes ne change pas (si w1 &lt; w2, alors w1 + C &lt; w2 + C). *   L'arbre qui minimise la somme des poids reste le même. *   La complexité reste donc identique.</p> <p>2. Si l'on souhaite trouver l'arbre couvrant de poids maximum. Est-ce que le problème devient difficile ?</p> <p>Réponse : Non. Le problème est symétrique. Pour trouver un Arbre Couvrant de Poids Maximum : *   Soit on multiplie tous les poids par -1 et on cherche le Minimum. *   Soit on modifie Kruskal pour trier les arêtes par ordre décroissant. *   Soit on modifie Prim pour choisir l'arête de poids maximum à chaque étape. La complexité reste la même.</p>","path":["Exercices Corrigés - Arbres Couvrants"],"tags":[]},{"location":"exercices_corriges/#exercice-4-propriete-de-larete-de-poids-minimum","level":2,"title":"Exercice 4 : Propriété de l'arête de poids minimum","text":"<p>Question : Soit G = (V, E, w) un graphe non-orienté valué. Montrez que l'arête e de poids minimum appartient toujours à un Arbre couvrant de poids minimum.</p> <p>Preuve (par l'absurde ou par la propriété de coupe) : Soit e = (u, v) l'arête de poids minimum unique du graphe. Supposons qu'il existe un Arbre Couvrant Minimum T qui ne contient pas e. 1.  Si on ajoute e à T, cela crée nécessairement un cycle (car T est un arbre couvrant, il connecte déjà u et v par un chemin). 2.  Ce cycle contient l'arête e et au moins une autre arête e' qui traverse la même coupe que e (c'est-à-dire une autre arête sur le chemin entre u et v dans T). 3.  Comme e est l'arête de poids minimum de tout le graphe, son poids w(e) est strictement inférieur à w(e'). 4.  Si on retire e' et qu'on garde e, on obtient un nouvel arbre T' qui est toujours couvrant. 5.  Le poids total de T' est Poids(T') = Poids(T) - w(e') + w(e). 6.  Puisque w(e) &lt; w(e'), alors Poids(T') &lt; Poids(T). 7.  Ceci contredit le fait que T était un Arbre Couvrant Minimum.</p> <p>Conclusion : L'arête de poids minimum doit faire partie de l'ACM (si elle est unique). Si plusieurs arêtes ont le même poids minimum, au moins l'une d'entre elles appartient à un ACM.</p>","path":["Exercices Corrigés - Arbres Couvrants"],"tags":[]},{"location":"exercices_corriges/#exercice-5-condition-de-connexite","level":2,"title":"Exercice 5 : Condition de connexité","text":"<p>Question : Montrez que G = (V, E) est un graphe connexe si et seulement si la frontière de tout sous-ensemble de sommets n'est pas vide.</p> <p>Explication : La frontière d'un ensemble X (notée parfois d(X)) est l'ensemble des arêtes qui relient un sommet dans X à un sommet hors de X.</p> <p>Preuve : *   Sens direct (=&gt;) : Si G est connexe.     Prenez n'importe quel groupe de sommets X (qui n'est ni vide, ni tout le graphe). Puisque le graphe est connexe, il est possible d'aller de n'importe quel sommet de X vers n'importe quel sommet hors de X. Il doit donc forcément y avoir une \"route\" (une arête) qui sort de X. Donc la frontière de X n'est pas vide.</p> <ul> <li>Sens réciproque (&lt;=) : Si la frontière n'est jamais vide.     Supposons par l'absurde que G n'est pas connexe.     Alors G est coupé en plusieurs morceaux isolés (composantes connexes). Prenons un de ces morceaux, appelons-le C1.     Si on regarde l'ensemble X = C1, comme c'est un morceau isolé, aucune arête ne le relie au reste du graphe.     Donc la frontière de C1 est vide.     Ceci contredit l'hypothèse de départ (\"la frontière n'est jamais vide\"). Donc G est forcément connexe.</li> </ul>","path":["Exercices Corrigés - Arbres Couvrants"],"tags":[]},{"location":"exercices_corriges/#exercice-6-unicite-de-la-liste-des-poids","level":2,"title":"Exercice 6 : Unicité de la liste des poids","text":"<p>Question : Soit L la liste triée des poids des arêtes d'un ACM T. Soit T' un autre ACM. Est-ce que la liste triée L' des poids de T' est égale à L ?</p> <p>Réponse : VRAI.</p> <p>Théorème : Pour un graphe donné, tous les arbres couvrants minimums ont exactement la même suite de poids d'arêtes.</p> <p>Intuition : Même si la structure de l'arbre (quelles arêtes sont choisies) peut changer si plusieurs arêtes ont le même poids, la quantité d'arêtes de chaque poids nécessaire pour connecter le graphe est fixe. Par exemple, si on a besoin de 2 arêtes de poids 1 et 1 arête de poids 2 pour connecter tout le monde au moindre coût, tous les ACM auront cette composition, même s'ils ne choisissent pas les mêmes arêtes de poids 1.</p>","path":["Exercices Corrigés - Arbres Couvrants"],"tags":[]},{"location":"flots/","level":1,"title":"Exercices Corrigés - Flots","text":"<p>Voici les corrections pour la série d'exercices sur les flots.</p>","path":["Exercices Corrigés - Flots"],"tags":[]},{"location":"flots/#exercice-1-algorithme-de-ford-fulkerson","level":2,"title":"Exercice 1 : Algorithme de Ford-Fulkerson","text":"<p>(Note : Le graphe n'étant pas visible, voici la méthode générale pour résoudre cet exercice)</p> <p>1. Exécution de l'algorithme</p>    Your browser does not support the video tag.  <pre><code>&lt;!-- slide --&gt;\n**État Initial**\nCapacités affichées sur les arcs. Flot = 0.\n\n```mermaid\ngraph LR\n    S((S)) --&gt;|10| A((A))\n    S --&gt;|10| B((B))\n    A --&gt;|5| B((B))\n    A --&gt;|5| T((T))\n    B --&gt;|10| T((T))\n```\n\n&lt;!-- slide --&gt;\n**Itération 1 : Chemin S -&gt; A -&gt; T**\nOn envoie 5 unités (limité par A-&gt;T).\nFlot Total = 5.\n\n```mermaid\ngraph LR\n    S((S)) --&gt;|5/10| A((A))\n    S --&gt;|0/10| B((B))\n    A --&gt;|0/5| B((B))\n    A --&gt;|5/5| T((T))\n    B --&gt;|0/10| T((T))\n    linkStyle 0 stroke:blue,stroke-width:3px\n    linkStyle 3 stroke:blue,stroke-width:3px\n```\n\n&lt;!-- slide --&gt;\n**Itération 2 : Chemin S -&gt; B -&gt; T**\nOn envoie 10 unités (limité par S-&gt;B et B-&gt;T).\nFlot Total = 5 + 10 = 15.\n\n```mermaid\ngraph LR\n    S((S)) --&gt;|5/10| A((A))\n    S --&gt;|10/10| B((B))\n    A --&gt;|0/5| B((B))\n    A --&gt;|5/5| T((T))\n    B --&gt;|10/10| T((T))\n    linkStyle 1 stroke:blue,stroke-width:3px\n    linkStyle 4 stroke:blue,stroke-width:3px\n```\n\n&lt;!-- slide --&gt;\n**Itération 3 : Chemin S -&gt; A -&gt; B -&gt; T ?**\nImpossible car B-&gt;T est saturé (10/10) et A-&gt;T est saturé (5/5).\nCependant, si on avait A-&gt;B avec capacité restante, on pourrait passer.\nIci, le flot est bloqué. Max Flow = 15.\n\n```mermaid\ngraph LR\n    S((S)) --&gt;|5/10| A((A))\n    S --&gt;|10/10| B((B))\n    A --&gt;|0/5| B((B))\n    A --&gt;|5/5| T((T))\n    B --&gt;|10/10| T((T))\n    style S fill:#cfc\n    style A fill:#cfc\n    style B fill:#fcc\n    style T fill:#fcc\n```\n*(En vert : sommets accessibles depuis S dans le résiduel. En rouge : inaccessibles. La coupe min est {A-&gt;T, S-&gt;B, A-&gt;B} ... attendez, S-&gt;B est saturé, A-&gt;T est saturé. Coupe = {S-&gt;B, A-&gt;T, A-&gt;B} ? Non, A-&gt;B a cap 5 et flot 0. Coupe Min = {S-&gt;B, A-&gt;T} de capacité 10+5=15).*\n</code></pre> <p>L'algorithme de Ford-Fulkerson fonctionne par itérations successives : 1.  Initialisation : Le flot est nul partout. 2.  Recherche de chemin augmentant : On cherche un chemin de la source (s) vers le puits (t) dans le graphe résiduel.     *   Le graphe résiduel contient les arcs où il reste de la capacité (capacité - flot actuel &gt; 0) et les arcs inverses là où il y a déjà du flot (pour pouvoir l'annuler). 3.  Augmentation : Si on trouve un chemin, on calcule la capacité résiduelle minimale sur ce chemin (le \"goulot d'étranglement\"). On augmente le flot de cette valeur le long du chemin. 4.  Répétition : On recommence tant qu'on trouve un chemin augmentant. 5.  Arrêt : Quand il n'y a plus de chemin de s à t, on a trouvé le flot maximum.</p> <p>2. Valeur du flot maximum C'est la somme des flots sortant de la source (ou entrant dans le puits) à la fin de l'algorithme.</p> <p>3. Coupe minimum La coupe minimum correspond à l'ensemble des arcs qui saturent et bloquent le passage. Pour la trouver : 1.  À la fin de l'algorithme, marquez tous les sommets accessibles depuis la source dans le graphe résiduel. Appelons cet ensemble S. 2.  Les autres sommets forment l'ensemble T. 3.  La coupe minimum est constituée de tous les arcs qui vont d'un sommet de S vers un sommet de T dans le graphe original. 4.  La somme des capacités de ces arcs est égale à la valeur du flot maximum (Théorème Max-Flow Min-Cut).</p>","path":["Exercices Corrigés - Flots"],"tags":[]},{"location":"flots/#exercice-2-realisation-dune-sequence-de-degres-graphe-biparti","level":2,"title":"Exercice 2 : Réalisation d'une séquence de degrés (Graphe Biparti)","text":"<p>Données : Deux séquences d'entiers r = (r1, ..., rn) et b = (b1, ..., bm) telles que la somme des r_i est égale à la somme des b_j. Problème : Existe-t-il un graphe biparti avec ces degrés ?</p> <p>1. Modélisation en Flot Maximum On construit un réseau de transport : *   Une Source S et un Puits T. *   Des nœuds pour chaque élément de R (gauche) et chaque élément de B (droite). *   Arcs S -&gt; R_i : Capacité = r_i (On veut que le sommet R_i ait exactement r_i arêtes, donc on lui envoie r_i unités de flot). *   Arcs B_j -&gt; T : Capacité = b_j (De même pour B_j). *   Arcs R_i -&gt; B_j : Capacité = 1 (Entre chaque paire, il peut y avoir au maximum 1 arête car c'est un graphe simple). On met un arc de chaque R_i vers chaque B_j.</p> <p>Condition d'existence : Il existe un graphe biparti respectant les degrés SI ET SEULEMENT SI le flot maximum dans ce réseau sature tous les arcs sortant de la source (et donc tous ceux entrant dans le puits). C'est-à-dire : Flot Max = Somme des r_i.</p> <p>2. Contre-exemple Prenons n=1, m=1. *   r = (2) *   b = (2) *   Somme r = 2, Somme b = 2. L'équation est vérifiée. *   Cependant, on a un seul sommet à gauche et un seul à droite. *   Dans un graphe simple, on ne peut mettre qu'une seule arête entre eux. *   Les degrés seront donc au maximum 1. Impossible d'avoir degré 2.</p> <p>3. Extension : Une seule séquence d (Graphe non orienté) Peut-on savoir si une séquence d = (d1, ..., dn) correspond à un graphe non orienté simple ? Oui, on peut aussi modéliser cela avec des flots, mais c'est plus subtil. *   On crée une source S et un puits T. *   On crée des nœuds représentant toutes les paires possibles {i, j} (les arêtes potentielles). *   On crée des nœuds pour chaque sommet i. *   Arcs S -&gt; Paire_{i,j} : Capacité = 1 (Chaque arête existe ou non). *   Arcs Paire_{i,j} -&gt; Sommet i et Paire_{i,j} -&gt; Sommet j : Capacité = 1 (Si l'arête est choisie, elle contribue au degré de i et de j). *   Arcs Sommet i -&gt; T : Capacité = d_i (Le degré voulu).</p> <p>Le problème a une solution si le flot max sature tous les arcs vers T (Flot Max = Somme des d_i). (Note : En pratique, pour ce problème spécifique, l'algorithme de Havel-Hakimi est plus simple et plus utilisé que les flots).</p>","path":["Exercices Corrigés - Flots"],"tags":[]},{"location":"k_connexite/","level":1,"title":"Exercices Corrigés - k-Connexité","text":"<p>Voici les corrections pour la série d'exercices sur la k-connexité.</p>","path":["Exercices Corrigés - k-Connexité"],"tags":[]},{"location":"k_connexite/#exercice-1-chemins-disjoints-entre-ensembles","level":2,"title":"Exercice 1 : Chemins disjoints entre ensembles","text":"<p>Question : Soit G un graphe k-connexe, et soient X et Y deux sous-ensembles de sommets de taille k. Montrez que G possède k chemins disjoints reliant X à Y.</p> <p>Preuve : On utilise le Théorème de Menger. Imaginez qu'on ajoute deux nouveaux sommets fictifs au graphe : *   Une \"super-source\" S reliée à tous les sommets de X. *   Un \"super-puits\" T relié à tous les sommets de Y.</p> <p>Puisque le graphe original est k-connexe, il faut supprimer au moins k sommets pour le déconnecter. Cela implique qu'il est impossible de séparer S de T en supprimant moins de k sommets (car X et Y sont de taille k et sont \"solidement\" attachés au reste du graphe). D'après le théorème de Menger, le nombre minimum de sommets à supprimer pour couper le chemin entre S et T est égal au nombre maximum de chemins disjoints entre S et T. Donc, il existe k chemins disjoints entre S et T. En retirant S et T, on obtient k chemins disjoints entre X et Y.</p>","path":["Exercices Corrigés - k-Connexité"],"tags":[]},{"location":"k_connexite/#exercice-2-2-connexite-et-degre-minimum","level":2,"title":"Exercice 2 : 2-connexité et Degré minimum","text":"<p>1. Un graphe G est 2-connexe si et seulement si il existe deux arbres couvrants disjoints.</p> <p>Réponse : FAUX. Contre-exemple : Un cycle simple avec n sommets (C_n). *   C'est un graphe 2-connexe (il faut couper 2 sommets pour le séparer). *   Il possède n arêtes. *   Un arbre couvrant a besoin de n-1 arêtes. *   Deux arbres couvrants disjoints auraient besoin de 2(n-1) arêtes. *   Pour n &gt; 2, on a 2n - 2 &gt; n. Il n'y a pas assez d'arêtes dans le cycle pour faire deux arbres.</p> <p>2. Si G est k-connexe alors le degré minimum delta(G) &gt;= k.</p> <p>Réponse : VRAI. Supposons qu'il existe un sommet v avec un degré strictement inférieur à k (par exemple k-1 voisins). Si on supprime ces k-1 voisins, le sommet v se retrouve totalement isolé du reste du graphe. On a donc réussi à déconnecter le graphe en supprimant moins de k sommets (k-1). Cela contredit le fait que le graphe est k-connexe. Donc, tous les sommets doivent avoir au moins k voisins.</p>","path":["Exercices Corrigés - k-Connexité"],"tags":[]},{"location":"k_connexite/#exercice-3-k-arete-connexe-vs-k-connexe","level":2,"title":"Exercice 3 : k-arête-connexe vs k-connexe","text":"<p>Définitions : *   k-connexe : Il faut supprimer au moins k sommets pour déconnecter le graphe. *   k-arête-connexe : Il faut supprimer au moins k arêtes pour déconnecter le graphe.</p> <p>1. Si G est k-arête-connexe, est-ce qu'il est k-connexe ?</p> <p>Réponse : NON. Il est généralement plus facile de casser un graphe en supprimant des sommets (qui emportent toutes leurs arêtes avec eux) qu'en supprimant des arêtes une par une. Exemple du \"Nœud Papillon\" (deux triangles reliés par un seul sommet central). *   Si on supprime le sommet central, le graphe est coupé. Il n'est donc pas 2-connexe (1-connexe seulement). *   Pourtant, pour le couper en supprimant des arêtes, il faut en enlever au moins 2. Il est donc 2-arête-connexe. La connexité par arêtes ne garantit pas la connexité par sommets.</p> <p>2. Réciproque : Si G est k-connexe, est-il k-arête-connexe ?</p> <p>Réponse : OUI. La connexité par sommets est une propriété plus forte. On a l'inégalité classique : (connexité sommets) &lt;= (connexité arêtes) &lt;= (degré minimum). Si la connexité sommets est k, alors la connexité arêtes est au moins k.</p>","path":["Exercices Corrigés - k-Connexité"],"tags":[]},{"location":"k_connexite/#exercice-4-cycle-passant-par-x-et-y","level":2,"title":"Exercice 4 : Cycle passant par x et y","text":"<p>Question : Soit G un graphe 2-connexe. Montrez que pour toute paire de sommets x, y il existe un cycle qui les contient.</p> <p>Preuve : Puisque G est 2-connexe, d'après le théorème de Menger, il existe au moins 2 chemins disjoints (qui ne partagent aucun sommet à part le début et la fin) entre x et y. Appelons ces chemins P1 et P2. *   P1 va de x à y. *   P2 va de x à y (par un autre chemin). Si on part de x, qu'on suit P1 jusqu'à y, et qu'on revient à x par P2 (en sens inverse), on forme une boucle fermée sans croisement. Cette boucle est un cycle qui contient x et y.</p>","path":["Exercices Corrigés - k-Connexité"],"tags":[]},{"location":"k_connexite/#exercice-5-chemins-arcs-disjoints-et-flot-maximum","level":2,"title":"Exercice 5 : Chemins arcs-disjoints et Flot Maximum","text":"<p>Question : Modéliser la recherche du nombre maximum de chemins arcs-disjoints entre x et y comme un problème de flot.</p> <p>Modélisation : 1.  Prendre le graphe orienté D. 2.  Assigner une capacité de 1 à chaque arc. 3.  Considérer x comme la Source et y comme le Puits. 4.  Calculer le Flot Maximum de x à y.</p> <p>Justification : Comme chaque arc a une capacité de 1, le flot ne peut passer qu'une seule fois par chaque arc. La valeur du flot maximum correspondra donc exactement au nombre de chemins que l'on peut emprunter simultanément sans réutiliser les mêmes arcs.</p>","path":["Exercices Corrigés - k-Connexité"],"tags":[]},{"location":"k_connexite/#exercice-6-chemins-sommets-disjoints-et-flots","level":2,"title":"Exercice 6 : Chemins sommets-disjoints et Flots","text":"<p>Question : Même question mais pour les chemins sommets-disjoints (qui ne partagent aucun sommet).</p> <p>Modélisation : Le problème est que le flot standard limite les arêtes, pas les sommets. Il faut transformer le graphe pour limiter le passage par les sommets. Technique du \"Dédoublement de Sommets\" (Vertex Splitting) : 1.  Pour chaque sommet v du graphe, on le remplace par deux sommets : v_entrée et v_sortie. 2.  On ajoute un arc (v_entrée -&gt; v_sortie) avec une capacité de 1. (C'est cet arc qui limite le passage par le sommet à 1 seule fois). 3.  Pour chaque arc original (u -&gt; v), on crée un arc (u_sortie -&gt; v_entrée) avec capacité infinie (ou 1). 4.  Calculer le Flot Max entre x_sortie et y_entrée.</p> <p>Application au graphe non orienté : Pour un graphe non orienté, on remplace d'abord chaque arête non orientée {u, v} par deux arcs orientés (u -&gt; v) et (v -&gt; u). Ensuite, on applique la même technique de dédoublement de sommets décrite ci-dessus. Cela permet de trouver le nombre maximum de chemins indépendants entre deux points, ce qui est très utile pour mesurer la robustesse d'un réseau.</p>","path":["Exercices Corrigés - k-Connexité"],"tags":[]},{"location":"kruskal_prim/","level":1,"title":"Algorithmes de Kruskal et Prim","text":"<p>Ce document détaille deux algorithmes fondamentaux pour trouver un Arbre Couvrant Minimum (ACM) dans un graphe.</p>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#introduction-arbre-couvrant-minimum-acm","level":2,"title":"Introduction : Arbre Couvrant Minimum (ACM)","text":"<p>Imaginez un réseau de villes reliées par des routes, où chaque route a un coût de construction. Un Arbre Couvrant Minimum est un moyen de relier toutes les villes entre elles en utilisant le moins de routes possible et pour le coût total le plus bas. Il ne doit pas y avoir de boucles (cycles) : il y a juste assez de routes pour que tout le monde soit connecté.</p>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#1-algorithme-de-kruskal","level":2,"title":"1. Algorithme de Kruskal","text":"","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#but","level":3,"title":"But","text":"<p>Construire le réseau en choisissant toujours la route la moins chère disponible, tant qu'elle ne crée pas de boucle inutile.</p>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#principe","level":3,"title":"Principe","text":"<p>L'algorithme de Kruskal est une approche gloutonne (on prend le meilleur choix immédiat) qui se concentre sur les arêtes (les routes). 1. On classe toutes les routes de la moins chère à la plus chère. 2. On regarde chaque route une par une. Si elle permet de relier deux zones qui n'étaient pas encore connectées ensemble, on la garde. Sinon (si les deux zones sont déjà reliées par un autre chemin), on la jette car elle créerait une boucle.</p>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#etapes-detaillees","level":3,"title":"Étapes détaillées","text":"<ol> <li>Initialisation : Au début, chaque ville est isolée, comme si elle était sa propre petite île.</li> <li>Tri : On fait une liste de toutes les routes possibles, triées par coût croissant (de la moins chère à la plus chère).</li> <li>Boucle : On prend la première route de la liste (la moins chère) :<ul> <li>Est-ce que cette route relie deux groupes de villes différents ?</li> <li>OUI : On construit la route. Les deux groupes de villes fusionnent pour n'en former qu'un seul plus grand.</li> <li>NON : Les deux villes sont déjà connectées (directement ou via d'autres villes). On ignore cette route pour éviter de faire un circuit fermé.</li> </ul> </li> <li>Fin : On s'arrête quand toutes les villes sont connectées ensemble.</li> </ol>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#complexite-efficacite","level":3,"title":"Complexité (Efficacité)","text":"<p>L'étape la plus longue est de trier toutes les routes par prix. Ensuite, vérifier si deux villes sont déjà connectées est très rapide grâce à des structures de données optimisées. C'est un algorithme efficace même pour des graphes assez grands.</p>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#trace-dexecution-exemple","level":3,"title":"Trace d'exécution (Exemple)","text":"Your browser does not support the video tag.  <pre><code>&lt;!-- slide --&gt;\n**Étape 0 : Initialisation**\nToutes les arêtes sont grises. Aucun sommet n'est connecté.\n\n```mermaid\ngraph LR\n    A((A)) ---|1| B((B))\n    B ---|2| D((D))\n    A ---|3| C((C))\n    C ---|4| D((D))\n    B ---|5| C((C))\n    style A fill:#fff,stroke:#333,stroke-width:2px\n    style B fill:#fff,stroke:#333,stroke-width:2px\n    style C fill:#fff,stroke:#333,stroke-width:2px\n    style D fill:#fff,stroke:#333,stroke-width:2px\n```\n\n&lt;!-- slide --&gt;\n**Étape 1 : Arête (A, B) - Poids 1**\nOn choisit l'arête la moins chère. Elle ne crée pas de cycle.\n\n```mermaid\ngraph LR\n    A((A)) ---|1| B((B))\n    B ---|2| D((D))\n    A ---|3| C((C))\n    C ---|4| D((D))\n    B ---|5| C((C))\n    style A fill:#cfc,stroke:#333,stroke-width:2px\n    style B fill:#cfc,stroke:#333,stroke-width:2px\n    linkStyle 0 stroke:green,stroke-width:4px\n```\n\n&lt;!-- slide --&gt;\n**Étape 2 : Arête (B, D) - Poids 2**\nLa suivante est (B, D). Elle connecte D au groupe {A, B}.\n\n```mermaid\ngraph LR\n    A((A)) ---|1| B((B))\n    B ---|2| D((D))\n    A ---|3| C((C))\n    C ---|4| D((D))\n    B ---|5| C((C))\n    style A fill:#cfc,stroke:#333,stroke-width:2px\n    style B fill:#cfc,stroke:#333,stroke-width:2px\n    style D fill:#cfc,stroke:#333,stroke-width:2px\n    linkStyle 0 stroke:green,stroke-width:4px\n    linkStyle 1 stroke:green,stroke-width:4px\n```\n\n&lt;!-- slide --&gt;\n**Étape 3 : Arête (A, C) - Poids 3**\nLa suivante est (A, C). Elle connecte C au reste.\n\n```mermaid\ngraph LR\n    A((A)) ---|1| B((B))\n    B ---|2| D((D))\n    A ---|3| C((C))\n    C ---|4| D((D))\n    B ---|5| C((C))\n    style A fill:#cfc,stroke:#333,stroke-width:2px\n    style B fill:#cfc,stroke:#333,stroke-width:2px\n    style C fill:#cfc,stroke:#333,stroke-width:2px\n    style D fill:#cfc,stroke:#333,stroke-width:2px\n    linkStyle 0 stroke:green,stroke-width:4px\n    linkStyle 1 stroke:green,stroke-width:4px\n    linkStyle 2 stroke:green,stroke-width:4px\n```\n\n&lt;!-- slide --&gt;\n**Étape 4 : Fin**\nLes arêtes restantes (C, D) et (B, C) créeraient des cycles (tous les sommets sont déjà connectés). L'algorithme s'arrête.\n\n```mermaid\ngraph LR\n    A((A)) ---|1| B((B))\n    B ---|2| D((D))\n    A ---|3| C((C))\n    C ---|4| D((D))\n    B ---|5| C((C))\n    style A fill:#cfc,stroke:#333,stroke-width:2px\n    style B fill:#cfc,stroke:#333,stroke-width:2px\n    style C fill:#cfc,stroke:#333,stroke-width:2px\n    style D fill:#cfc,stroke:#333,stroke-width:2px\n    linkStyle 0 stroke:green,stroke-width:4px\n    linkStyle 1 stroke:green,stroke-width:4px\n    linkStyle 2 stroke:green,stroke-width:4px\n    linkStyle 3 stroke:red,stroke-width:1px,stroke-dasharray: 5 5\n    linkStyle 4 stroke:red,stroke-width:1px,stroke-dasharray: 5 5\n```\n</code></pre> <p>Soit le graphe suivant : *   Sommets : A, B, C, D *   Arêtes :     *   (A, B) : 1     *   (B, D) : 2     *   (A, C) : 3     *   (C, D) : 4     *   (B, C) : 5</p> <p>(Les routes C-D et B-C sont ignorées car elles relieraient des villes déjà connectées au réseau).</p>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#2-algorithme-de-prim","level":2,"title":"2. Algorithme de Prim","text":"","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#but_1","level":3,"title":"But","text":"<p>Construire le réseau en partant d'une ville et en s'étendant petit à petit vers les villes voisines les plus proches.</p>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#principe_1","level":3,"title":"Principe","text":"<p>L'algorithme de Prim est aussi une approche gloutonne, mais qui se concentre sur les sommets (les villes). 1. On choisit une ville de départ au hasard. 2. À chaque étape, on regarde toutes les routes qui partent des villes déjà connectées vers l'extérieur. On choisit la moins chère pour ajouter une nouvelle ville au réseau.</p>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#etapes-detaillees_1","level":3,"title":"Étapes détaillées","text":"<ol> <li>Initialisation : On choisit une ville de départ (n'importe laquelle). C'est notre \"réseau actuel\".</li> <li>Boucle : Tant qu'il reste des villes non connectées :<ul> <li>On regarde toutes les routes possibles qui partent d'une ville dans notre réseau vers une ville hors de notre réseau.</li> <li>On choisit la route la moins chère parmi celles-ci.</li> <li>On ajoute cette route et la nouvelle ville à notre réseau.</li> </ul> </li> <li>Fin : Quand toutes les villes sont dans le réseau.</li> </ol>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#complexite-efficacite_1","level":3,"title":"Complexité (Efficacité)","text":"<p>L'efficacité dépend de la façon dont on trouve rapidement la prochaine route la moins chère. C'est généralement très efficace, surtout si le réseau a beaucoup de routes (graphe dense).</p>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#trace-dexecution-meme-exemple","level":3,"title":"Trace d'exécution (Même exemple)","text":"Your browser does not support the video tag.  <pre><code>&lt;!-- slide --&gt;\n**Étape 0 : Initialisation**\nOn part de A.\n\n```mermaid\ngraph LR\n    A((A)) ---|1| B((B))\n    B ---|2| D((D))\n    A ---|3| C((C))\n    C ---|4| D((D))\n    B ---|5| C((C))\n    style A fill:#f9f,stroke:#333,stroke-width:4px\n```\n\n&lt;!-- slide --&gt;\n**Étape 1 : Choix (A, B)**\nVoisins de A : B(1), C(3). Le min est B.\n\n```mermaid\ngraph LR\n    A((A)) ---|1| B((B))\n    B ---|2| D((D))\n    A ---|3| C((C))\n    C ---|4| D((D))\n    B ---|5| C((C))\n    style A fill:#f9f,stroke:#333,stroke-width:4px\n    style B fill:#f9f,stroke:#333,stroke-width:4px\n    linkStyle 0 stroke:magenta,stroke-width:4px\n```\n\n&lt;!-- slide --&gt;\n**Étape 2 : Choix (B, D)**\nVoisins accessibles : C(3) [via A], D(2) [via B], C(5) [via B]. Le min est D(2).\n\n```mermaid\ngraph LR\n    A((A)) ---|1| B((B))\n    B ---|2| D((D))\n    A ---|3| C((C))\n    C ---|4| D((D))\n    B ---|5| C((C))\n    style A fill:#f9f,stroke:#333,stroke-width:4px\n    style B fill:#f9f,stroke:#333,stroke-width:4px\n    style D fill:#f9f,stroke:#333,stroke-width:4px\n    linkStyle 0 stroke:magenta,stroke-width:4px\n    linkStyle 1 stroke:magenta,stroke-width:4px\n```\n\n&lt;!-- slide --&gt;\n**Étape 3 : Choix (A, C)**\nVoisins accessibles : C(3) [via A], C(5) [via B], C(4) [via D]. Le min est C(3).\n\n```mermaid\ngraph LR\n    A((A)) ---|1| B((B))\n    B ---|2| D((D))\n    A ---|3| C((C))\n    C ---|4| D((D))\n    B ---|5| C((C))\n    style A fill:#f9f,stroke:#333,stroke-width:4px\n    style B fill:#f9f,stroke:#333,stroke-width:4px\n    style D fill:#f9f,stroke:#333,stroke-width:4px\n    style C fill:#f9f,stroke:#333,stroke-width:4px\n    linkStyle 0 stroke:magenta,stroke-width:4px\n    linkStyle 1 stroke:magenta,stroke-width:4px\n    linkStyle 2 stroke:magenta,stroke-width:4px\n```\n</code></pre> <p>Graphe : *   Sommets : A, B, C, D *   Arêtes : (A,B):1, (B,D):2, (A,C):3, (C,D):4, (B,C):5</p>","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"kruskal_prim/#resume-comparatif","level":2,"title":"Résumé Comparatif","text":"Caractéristique Kruskal Prim Idée principale On trie toutes les routes et on prend les moins chères (si pas de boucle). On part d'une ville et on grandit comme une tache d'huile vers la plus proche. Approche Globale (on regarde toutes les routes d'un coup). Locale (on regarde juste autour de ce qu'on a déjà). Meilleur usage Quand il y a peu de routes (graphe \"aéré\"). Quand il y a beaucoup de routes (graphe \"dense\").","path":["Algorithmes de Kruskal et Prim"],"tags":[]},{"location":"plus_courts_chemins/","level":1,"title":"Exercices Corrigés - Plus Courts Chemins","text":"<p>Voici les corrections pour la série d'exercices sur les plus courts chemins.</p>","path":["Exercices Corrigés - Plus Courts Chemins"],"tags":[]},{"location":"plus_courts_chemins/#exercice-1-dijkstra-et-cycles-negatifs","level":2,"title":"Exercice 1 : Dijkstra et Cycles Négatifs","text":"<p>Question : Dans un graphe pondéré, en présence de cycles négatifs, exhibez un exemple où l'algorithme de Dijkstra ne trouve pas le plus court chemin.</p> <p>Réponse : L'algorithme de Dijkstra suppose que lorsqu'on \"valide\" un sommet (qu'on le sort de la file d'attente), on a définitivement trouvé son plus court chemin. Cette hypothèse est fausse si des arêtes ont des poids négatifs, et encore plus s'il y a des cycles négatifs.</p> <p>Exemple d'exécution (Graphe sans poids négatifs) :</p>    Your browser does not support the video tag.  <p>Exemple simple (Arête négative) : *   Sommets : A, B, C *   Arêtes :     *   A -&gt; B (coût 2)     *   A -&gt; C (coût 5)     *   B -&gt; C (coût -10)</p> <p>Déroulement de Dijkstra (partant de A) : 1.  On visite A. Voisins : B (2), C (5). 2.  Le plus proche est B (2). On valide B. 3.  On regarde les voisins de B : C est accessible avec un coût total de 2 + (-10) = -8.     *   Problème : Si Dijkstra a déjà validé C (dans un graphe plus complexe) ou s'il ne met pas à jour correctement les priorités, il échoue.     *   Mais le vrai problème des cycles négatifs est que le chemin peut devenir infiniment petit (ex: A -&gt; B -&gt; A avec coût total -1). Dijkstra ne détecte pas cela et peut tourner en boucle ou donner un résultat faux.</p>","path":["Exercices Corrigés - Plus Courts Chemins"],"tags":[]},{"location":"plus_courts_chemins/#exercice-2-produit-des-poids","level":2,"title":"Exercice 2 : Produit des poids","text":"<p>Question : On veut trouver le chemin qui minimise le produit des poids (tous &gt;= 1). Comment faire ?</p> <p>Réponse : On utilise les logarithmes. On sait que : log(a * b) = log(a) + log(b). Minimiser un produit revient à minimiser la somme des logarithmes.</p> <p>Algorithme : 1.  Transformer le graphe : remplacer chaque poids w par son logarithme : w' = log(w). 2.  Comme w &gt;= 1, alors log(w) &gt;= 0. Tous les nouveaux poids sont positifs. 3.  Appliquer l'algorithme de Dijkstra classique sur ce nouveau graphe. 4.  Le chemin trouvé sera celui qui minimise la somme des log, et donc le produit des poids initiaux.</p>","path":["Exercices Corrigés - Plus Courts Chemins"],"tags":[]},{"location":"plus_courts_chemins/#exercice-3-chemin-le-plus-fiable-probabilites","level":2,"title":"Exercice 3 : Chemin le plus fiable (Probabilités)","text":"<p>Question : Les poids sont des probabilités (entre 0 et 1). On veut maximiser la probabilité d'arrivée (produit des probabilités sur le chemin).</p> <p>Réponse : C'est similaire à l'exercice précédent, mais on veut maximiser un produit de nombres entre 0 et 1. On sait que log(p) est négatif (car p &lt;= 1). Pour se ramener à un problème de plus court chemin (minimisation de somme positive), on utilise : -log(p).</p> <p>Algorithme : 1.  Transformer le graphe : remplacer chaque probabilité p par w' = -log(p). 2.  Comme p &lt;= 1, log(p) &lt;= 0, donc -log(p) &gt;= 0. Les nouveaux poids sont positifs. 3.  Chercher le chemin qui minimise la somme des w' (ce qui revient à maximiser le produit des p). 4.  Utiliser Dijkstra.</p>","path":["Exercices Corrigés - Plus Courts Chemins"],"tags":[]},{"location":"plus_courts_chemins/#exercice-4-plus-long-chemin-et-cycles-negatifs","level":2,"title":"Exercice 4 : Plus long chemin et cycles négatifs","text":"<p>Question : Montrez que si nous savons résoudre le problème du plus court chemin en présence de cycle de longueur négative, alors nous savons résoudre le problème du plus long chemin.</p> <p>Réponse : Le problème du \"Plus Long Chemin\" dans un graphe G est équivalent au problème du \"Plus Court Chemin\" dans un graphe G' où tous les poids sont inversés (multipliés par -1).</p> <p>Réduction : 1.  Construire G' identique à G, mais pour chaque arête de poids w, on lui donne le poids -w. 2.  Chercher le plus court chemin dans G'.     *   Si on trouve un chemin de longueur L dans G', cela correspond à un chemin de longueur -L dans G.     *   Minimiser (-L) revient à Maximiser L. 3.  Attention : Si G a des cycles positifs, G' aura des cycles négatifs.     *   C'est pourquoi on a besoin d'un algorithme capable de gérer les cycles négatifs (comme supposé dans l'énoncé).</p>","path":["Exercices Corrigés - Plus Courts Chemins"],"tags":[]},{"location":"plus_courts_chemins/#exercice-5-complexite-de-dijkstra","level":2,"title":"Exercice 5 : Complexité de Dijkstra","text":"<p>Question : Est-ce que l'algorithme de Dijkstra (avec tas de Fibonacci) peut s'exécuter en temps inférieur à o(m + n log n) ?</p> <p>Réponse : Non (dans le cas général). La complexité O(m + n log n) est considérée comme optimale pour les algorithmes basés sur la comparaison dans des graphes généraux. *   Le terme \"n log n\" vient de la nécessité de trier les sommets par distance (similaire au tri d'une liste). *   On sait que trier n éléments par comparaison prend au minimum O(n log n). *   Si on pouvait faire Dijkstra beaucoup plus vite, on pourrait l'utiliser pour trier des nombres plus vite que la limite théorique, ce qui est impossible (avec des comparaisons uniquement).</p>","path":["Exercices Corrigés - Plus Courts Chemins"],"tags":[]}]}